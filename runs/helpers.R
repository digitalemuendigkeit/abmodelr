#PLESE DO NOT COPY PASTE CODE FROM OTHER FILES HERE!
#instead, source the function if neccessary, otherwise there will be different versions of the same code all over the project

load_config <- function(project_dir) {
  #' read yaml files from a specified project directory
  #' the directory should be located in /runs
  #' 
  #' @param project_dir directory name within folder "runs"
  #'   
  #' @return yaml_list: list of attributes of different runs
  
  # create lists
  file_list <- list.files(here::here("runs", "projects", project_dir, "yaml_setup"))
  yaml_list <- list()
  
  # read files and append to list
  for (i in file_list) {
    yaml_list <- rlist::list.append(
      yaml_list, 
      yaml::read_yaml(
        here::here("runs", "projects", project_dir, "yaml_setup", i)
      )
    )
  }
  
  # adjust names
  names(yaml_list) <- file_list
  
  # return list
  return (yaml_list)
  
}

source(here::here("user_generation.R"))
source(here::here("posts_generation.R"))
source(here::here("generate_cosine_Matrix.R"))

#' generate_news <- function(config) {
#'   #' generate news posts from config object
#'   #' 
#'   #' @param config a config item generated by read_yaml from a YAML file
#'   #' 
#'   #' @return news_posts: the generated news posts
#'   
#'   # read topic models
#'   models <- read_rds("topic_modeling/topicmodels.rds") 
#'   
#'   # setup
#'   if (config$n_topics %in% models$k) {
#'     topic_count <- config$n_topics
#'   } else {
#'     topic_count <- max(models$k)
#'     message(paste0("Number of topics (",config$n_topics,") not availble. Choosing ", topic_count, " topics."))
#'   }
#'   
#'   # create covariance matrix
#'   cov_mat <- models %>% filter(k == topic_count) %>% 
#'     unique() %>% 
#'     pull(covmat) %>% 
#'     unlist() %>% 
#'     matrix(nrow = topic_count) 
#'   
#'   mean_vec <- rep(0.5,nrow(cov_mat))
#'   
#'   # create ids 
#'   total_newsposts <-config$n_newsposts + config$n_newsposts_step * config$n_steps
#'   news_ids <- 1:total_newsposts
#'   topic_relevances <- data.frame(news_ids)
#'   
#'   # create news posts with certain topics
#'   # for (i in 1:config$n_topics) {
#'   # # assign topic relevante by uniform distribution
#'   #   topic_relevance <- data.frame(runif(total_newsposts))
#'   #   names(topic_relevance) <- paste0("topic_", i)
#'   #   topic_relevances <- topic_relevances %>% bind_cols(topic_relevance)
#'   # }
#'   
#'   relevs <- as_tibble(MASS::mvrnorm(n=total_newsposts, mu = mean_vec, Sigma = cov_mat))
#'   names(relevs) <- paste0("topic_", 1:config$n_topics)
#'   topic_relevances <- topic_relevances %>% bind_cols(relevs)
#'   
#'   news_posts <- data.frame(topic_relevances)
#'   
#'   # calculate the sum of topic interests, to measure the "likeability"(?) of post
#'   news_posts %>% select(starts_with("topic")) %>% 
#'     mutate(sumtopics = rowSums(.)) %>% select(sumtopics) -> sumcol
#'   news_posts %>% bind_cols(sumcol) -> news_posts
#'   
#'   # Define a random likebility score for all news posts (uniform distribution, between 0 and topic-limit)
#'   news_scores <- runif(total_newsposts, min = 1, max = config$topic_limit)
#'   
#'   # get all topic values into a matrix for normalization
#'   news_posts %>% select(starts_with("topic")) -> matrix_of_initial_values
#'   
#'   # normalize all topic-value by the rowwise sum (generated above) - now sums should be 1
#'   updated_topics <- (matrix_of_initial_values / t(sumcol)) 
#'   
#'   # update the news_posts
#'   news_posts <- bind_cols(data.frame(news_ids), updated_topics, data.frame(news_scores))
#'   
#'   # return news posts
#'   return (news_posts)
#'   
#' }

#' generate_cosine_matrix <- function(user, news_posts) {
#'   #' generate a cosine matrix
#'   #' 
#'   #' @param user a user data frame
#'   #' @param news_posts a news post data frame
#'   #' 
#'   #' @return cosine_matrix: the generated cosine matrix
#'   
#'   user %>% select(starts_with("topic")) -> mat_user
#'   
#'   news_posts %>% select(starts_with("topic")) -> mat_posts
#'   
#'   cosine_matrix <- matrix(c(0), nrow = config$n_users, ncol = total_newsposts)
#'   
#'   for(i in 1:config$n_users) {
#'     for(j in 1:total_newsposts) {
#'       cosine_matrix[i,j] <- lsa::cosine(unlist(mat_user[i,]), unlist(mat_posts[j,]))
#'     }
#'   }
#'   
#'   # return the cosine matrix
#'   return (cosine_matrix)
#'   
#' }

initialize_project <- function(n_iterations, n_conditions, project_name, rndm_seeds, copy_location = NULL) {
  #' automatically write R-scripts for simulation runs
  #' 
  #' @param n_iterations number of simulation iterations
  #' @param n_conditions number of experimental conditions
  #' @param project_name name of the simulation project
  #' @param rndm_seeds list of normally distributed random seeds
  
  # set maximum number of iterations
  if (n_iterations > 50) {
    print("Please consider doing less iterations (your computer will thank you for it!")
    return (FALSE)
  }
  
  # create directory to store results
  dir.create(here::here("runs", "projects", toString(project_name), "results"))
  
  
  for (i in 1:length(config_length)) {
    
    cond <- i
    
    path <- here::here(
      "runs", "projects", toString(project_name), 
      paste0("cond-", toString(cond), ".R")
    )
    
    write(paste0("", "\n"), file = path)
    
    for (j in 1:n_iterations) {
      
      iteration <- j
      
      # open connection to template file
      con_tmpl <- file(here::here("runs", "template.R"), "r+")
      lines_tmpl <- readLines(con_tmpl)
      
      # write libraries
      write(
        lines_tmpl[1:11],
        file = path,
        append = TRUE
      )
      
      # write loading of config file
      write(
        paste0(
          "config <- load_config(\"", project_name, 
          "\")[[\"", "cond-", toString(cond), ".yml", "\"]]", "\n"
        ),
        file = path,
        append = TRUE
      )
      
      # write setting of random seed
      write(
        lines_tmpl[14],
        file = path,
        append = TRUE
      )
      
      write(
        paste0(
          "set.seed(", toString(rndm_seeds[j]), ")", "\n"
        ),
        file = path,
        append = TRUE
      )
      
      # write body of script
      write(
        lines_tmpl[16:201],
        file = path,
        append = TRUE
      )
      
      # write file saving
      write(
        paste0(
          "rds_filename <- paste0(\"", toString(cond), "-", toString(iteration), 
          "\", \"-\", ", "config$outputfilename)", "\n", "write_rds(", 
          "path = here::here(", "\"runs\", \"projects\", \"", toString(project_name), 
          "\", \"results\", rds_filename), x = results_data)", "\n"
        ),
        file = path,
        append = TRUE
      )
      
      # write cleaning up environment
      write(
        paste0("\n", "rm(list = ls())", "\n", "\n"),
        file = path,
        append = TRUE
      )
      
      # close connection to template file
      close(con_tmpl)
      
    }
      
  }
  
  # write the runner file
  if(!is.null(copy_location)){
    
    cmd <- paste0("    file.copy(from = here::here(\"runs\", \"projects\", \"",toString(project_name),"\"), recursive = T, to=\"",copy_location,"\")")
    
  } else {
    cmd <- ""
  }
  path <- here::here("runs", "projects", toString(project_name), 
    paste0("runner.R"))
  
  # Generate runner file
  code <- paste(c("# This is a runner file to be started as a job in RStudio"),
                 "#do trials in parellel loop",
                 "library(foreach)",
                  "library(doParallel)",
                  "#setup parallel backend to use many processors","",
                "cores=detectCores()",
                "cl <- makeCluster(cores[1]-1) #not to overload your computer",
                "registerDoParallel(cl)","",
                paste0("foreach(i=1:",length(config_length),") %dopar% {"),
                paste0("   source(here::here(\"runs\", \"projects\", \"",toString(project_name),"\", paste0(\"cond-\", i, \".R\")))"),
                cmd,
                "}", sep = "\n")
  
  writeLines(code, path)

}



