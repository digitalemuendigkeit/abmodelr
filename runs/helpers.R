load_config <- function(project_dir) {
  #' read yaml files from a specified project directory
  #' the directory should be located in /runs
  #' 
  #' @param project_dir directory name within folder "runs"
  #'   
  #' @return yaml_list: list of attributes of different runs
  
  # create lists
  file_list <- list.files(here::here("runs", "projects", project_dir, "yaml_setup"))
  yaml_list <- list()
  
  # read files and append to list
  for (i in file_list) {
    yaml_list <- rlist::list.append(
      yaml_list, 
      yaml::read_yaml(
        here::here("runs", "projects", project_dir, "yaml_setup", i)
      )
    )
  }
  
  # adjust names
  names(yaml_list) <- file_list
  
  # return list
  return (yaml_list)
  
}

generate_users <- function(config) {
  #' create the user data frame
  #' 
  #'   @param config a config item generated by read_yaml from a YAML file
  #' 
  #'   @return user: a user data frame
  
  user_ids <- 1:config$n_users
  
  # initialize interest_resource with 3 times the amount of topics, 
  # so that users have head room to increase their interest
  interest_resource <- rep(config$n_topics * 3, config$n_users)
  
  # setup a data frame for all users
  topic_interests <- data.frame(user_ids)
  
  # generate interests for the users by topic
  for (i in 1:config$n_topics) {
    
    # randomly assign interest to topics using the uniform distribution
    topic_interest_level <- data.frame(runif(config$n_users))
    
    # assign sensible column names
    names(topic_interest_level) <- paste0("topic_", i)
    
    # bind all topic interest to the user
    topic_interests <- topic_interests %>% bind_cols(topic_interest_level)
    
  }
  
  # create the actual user data frame
  user <- data.frame(topic_interests, interest_resource)
  
  # return the user data frame
  return (user)
  
}

generate_news <- function(config) {
  #' generate news posts from config object
  #' 
  #' @param config a config item generated by read_yaml from a YAML file
  #' 
  #' @return news_posts: the generated news posts
  
  # read topic models
  models <- read_rds("topic_modeling/topicmodels.rds") 
  
  # setup
  if (config$n_topics %in% models$k) {
    topic_count <- config$n_topics
  } else {
    topic_count <- max(models$k)
    message(paste0("Number of topics (",config$n_topics,") not availble. Choosing ", topic_count, " topics."))
  }
  
  # create covariance matrix
  cov_mat <- models %>% filter(k == topic_count) %>% 
    unique() %>% 
    pull(covmat) %>% 
    unlist() %>% 
    matrix(nrow = topic_count) 
  
  mean_vec <- rep(0.5,nrow(cov_mat))
  
  # create ids 
  total_newsposts <-config$n_newsposts + config$n_newsposts_step * config$n_steps
  news_ids <- 1:total_newsposts
  topic_relevances <- data.frame(news_ids)
  
  # create news posts with certain topics
  # for (i in 1:config$n_topics) {
  # # assign topic relevante by uniform distribution
  #   topic_relevance <- data.frame(runif(total_newsposts))
  #   names(topic_relevance) <- paste0("topic_", i)
  #   topic_relevances <- topic_relevances %>% bind_cols(topic_relevance)
  # }
  
  relevs <- as_tibble(MASS::mvrnorm(n=total_newsposts, mu = mean_vec, Sigma = cov_mat))
  names(relevs) <- paste0("topic_", 1:config$n_topics)
  topic_relevances <- topic_relevances %>% bind_cols(relevs)
  
  news_posts <- data.frame(topic_relevances)
  
  # calculate the sum of topic interests, to measure the "likeability"(?) of post
  news_posts %>% select(starts_with("topic")) %>% 
    mutate(sumtopics = rowSums(.)) %>% select(sumtopics) -> sumcol
  news_posts %>% bind_cols(sumcol) -> news_posts
  
  # Define a random likebility score for all news posts (uniform distribution, between 0 and topic-limit)
  news_scores <- runif(total_newsposts, min = 1, max = config$topic_limit)
  
  # get all topic values into a matrix for normalization
  news_posts %>% select(starts_with("topic")) -> matrix_of_initial_values
  
  # normalize all topic-value by the rowwise sum (generated above) - now sums should be 1
  updated_topics <- (matrix_of_initial_values / t(sumcol)) 
  
  # update the news_posts
  news_posts <- bind_cols(data.frame(news_ids), updated_topics, data.frame(news_scores))
  
  # return news posts
  return (news_posts)
  
}

generate_cosine_matrix <- function(user, news_posts) {
  #' generate a cosine matrix
  #' 
  #' @param user a user data frame
  #' @param news_posts a news post data frame
  #' 
  #' @return cosine_matrix: the generated cosine matrix
  
  user %>% select(starts_with("topic")) -> mat_user
  
  news_posts %>% select(starts_with("topic")) -> mat_posts
  
  cosine_matrix <- matrix(c(0), nrow = config$n_users, ncol = total_newsposts)
  
  for(i in 1:config$n_users) {
    for(j in 1:total_newsposts) {
      cosine_matrix[i,j] <- lsa::cosine(unlist(mat_user[i,]), unlist(mat_posts[j,]))
    }
  }
  
  # return the cosine matrix
  return (cosine_matrix)
  
}

initialize_project <- function(n_iterations, n_conditions, project_name, rndm_seeds) {
  #' automatically write R-scripts for simulation runs
  #' 
  #' @param n_iterations number of simulation iterations
  #' @param n_conditions number of experimental conditions
  #' @param project_name name of the simulation project
  #' @param rndm_seeds list of normally distributed random seeds
  
  # set maximum number of iterations
  if (n_iterations > 50) {
    print("Please consider doing less iterations (your computer will thank you for it!")
    return (FALSE)
  }
  
  # create directory to store results
  dir.create(here::here("runs", "projects", toString(project_name), "results"))
  
  
  for (i in 1:length(config_length)) {
    
    cond <- i
    
    path <- here::here(
      "runs", "projects", toString(project_name), 
      paste0("cond-", toString(cond), ".R")
    )
    
    write(paste0("", "\n"), file = path)
    
    for (j in 1:n_iterations) {
      
      iteration <- j
      
      # open connection to template file
      con_tmpl <- file(here::here("runs", "template.R"), "r+")
      lines_tmpl <- readLines(con_tmpl)
      
      # write libraries
      write(
        lines_tmpl[1:11],
        file = path,
        append = TRUE
      )
      
      # write loading of config file
      write(
        paste0(
          "config <- load_config(\"", project_name, 
          "\")[[\"", "cond-", toString(cond), ".yml", "\"]]", "\n"
        ),
        file = path,
        append = TRUE
      )
      
      # write setting of random seed
      write(
        lines_tmpl[14],
        file = path,
        append = TRUE
      )
      
      write(
        paste0(
          "set.seed(", toString(rndm_seeds[j]), ")", "\n"
        ),
        file = path,
        append = TRUE
      )
      
      # write body of script
      write(
        lines_tmpl[16:194],
        file = path,
        append = TRUE
      )
      
      # write file saving
      write(
        paste0(
          "rds_filename <- paste0(\"", toString(cond), "-", toString(iteration), 
          "\", \"-\", ", "config$outputfilename)", "\n", "write_rds(", 
          "path = here::here(", "\"runs\", \"projects\", \"", toString(project_name), 
          "\", \"results\"), x = results_data)", "\n"
        ),
        file = path,
        append = TRUE
      )
      
      # write cleaning up environment
      write(
        paste0("\n", "rm(list = ls())", "\n", "\n"),
        file = path,
        append = TRUE
      )
      
      # close connection to template file
      close(con_tmpl)
      
    }
      
  }

}



ResetR = function() {
  
  # 1) Remove all objects
  rm(list = ls(all=TRUE, envir = .GlobalEnv), envir = .GlobalEnv)
  
  # 2) Unload non-native packages. 
  nat = c(".GlobalEnv", "package:datasets", "package:evd", "package:nortest", "package:MASS", "package:stats", "package:graphics", "package:grDevices", "package:utils", "package:methods", "Autoloads", "package:base")
  
  p = search()
  for (i in p) {
    if (is.na(match(i, nat))) {
      try(eval(parse(text=paste0("detach(", i, ", unload=T, force=T)"))), silent=T) # force=T is need in case package has dependency
    }
  }
  
  # 3) Close all connections
  try(closeAllConnections(), silent=T)
  
  # 4) Restore default options
  try(options(baseenv()$.Options2), silent=T) # Remember to put assign(".Options2", options(), baseenv()) at the bottom of YOUR_R_HOME\etc\Rprofile.site
  
  # 5) Close all graphic devices
  graphics.off()
  
}